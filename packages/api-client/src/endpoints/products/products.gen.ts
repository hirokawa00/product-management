/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * PIM (Product Information Management) API
 * ÂïÜÂìÅÊÉÖÂ†±ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆAPIÂÆöÁæ©
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetProducts200,
  GetProductsParams,
  Product,
  ProductCreateRequest,
  ProductUpdateRequest
} from '../../model';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * @summary ÂïÜÂìÅ‰∏ÄË¶ßÂèñÂæó
 */
export type getProductsResponse200 = {
  data: GetProducts200
  status: 200
}
    
export type getProductsResponseComposite = getProductsResponse200;
    
export type getProductsResponse = getProductsResponseComposite & {
  headers: Headers;
}

export const getGetProductsUrl = (params?: GetProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/products?${stringifiedParams}` : `/products`
}

export const getProducts = async (params?: GetProductsParams, options?: RequestInit): Promise<getProductsResponse> => {
  
  const res = await fetch(getGetProductsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getProductsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getProductsResponse
}



export const getGetProductsQueryKey = (params?: GetProductsParams,) => {
    return [`/products`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProductsQueryOptions = <TData = Awaited<ReturnType<typeof getProducts>>, TError = unknown>(params?: GetProductsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducts>>> = ({ signal }) => getProducts(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProductsQueryResult = NonNullable<Awaited<ReturnType<typeof getProducts>>>
export type GetProductsQueryError = unknown


/**
 * @summary ÂïÜÂìÅ‰∏ÄË¶ßÂèñÂæó
 */

export function useGetProducts<TData = Awaited<ReturnType<typeof getProducts>>, TError = unknown>(
 params?: GetProductsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetProductsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary ÂïÜÂìÅ‰ΩúÊàê
 */
export type postProductsResponse201 = {
  data: Product
  status: 201
}
    
export type postProductsResponseComposite = postProductsResponse201;
    
export type postProductsResponse = postProductsResponseComposite & {
  headers: Headers;
}

export const getPostProductsUrl = () => {


  

  return `/products`
}

export const postProducts = async (productCreateRequest: ProductCreateRequest, options?: RequestInit): Promise<postProductsResponse> => {
  
  const res = await fetch(getPostProductsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      productCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postProductsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postProductsResponse
}




export const getPostProductsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postProducts>>, TError,{data: ProductCreateRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postProducts>>, TError,{data: ProductCreateRequest}, TContext> => {

const mutationKey = ['postProducts'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postProducts>>, {data: ProductCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postProducts(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostProductsMutationResult = NonNullable<Awaited<ReturnType<typeof postProducts>>>
    export type PostProductsMutationBody = ProductCreateRequest
    export type PostProductsMutationError = unknown

    /**
 * @summary ÂïÜÂìÅ‰ΩúÊàê
 */
export const usePostProducts = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postProducts>>, TError,{data: ProductCreateRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postProducts>>,
        TError,
        {data: ProductCreateRequest},
        TContext
      > => {

      const mutationOptions = getPostProductsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary ÂïÜÂìÅË©≥Á¥∞ÂèñÂæó
 */
export type getProductsProductIdResponse200 = {
  data: Product
  status: 200
}
    
export type getProductsProductIdResponseComposite = getProductsProductIdResponse200;
    
export type getProductsProductIdResponse = getProductsProductIdResponseComposite & {
  headers: Headers;
}

export const getGetProductsProductIdUrl = (productId: string,) => {


  

  return `/products/${productId}`
}

export const getProductsProductId = async (productId: string, options?: RequestInit): Promise<getProductsProductIdResponse> => {
  
  const res = await fetch(getGetProductsProductIdUrl(productId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getProductsProductIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getProductsProductIdResponse
}



export const getGetProductsProductIdQueryKey = (productId?: string,) => {
    return [`/products/${productId}`] as const;
    }

    
export const getGetProductsProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductsProductId>>, TError = unknown>(productId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProductsProductId>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductsProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductsProductId>>> = ({ signal }) => getProductsProductId(productId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductsProductId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProductsProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductsProductId>>>
export type GetProductsProductIdQueryError = unknown


/**
 * @summary ÂïÜÂìÅË©≥Á¥∞ÂèñÂæó
 */

export function useGetProductsProductId<TData = Awaited<ReturnType<typeof getProductsProductId>>, TError = unknown>(
 productId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProductsProductId>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetProductsProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary ÂïÜÂìÅÊõ¥Êñ∞
 */
export type putProductsProductIdResponse200 = {
  data: Product
  status: 200
}
    
export type putProductsProductIdResponseComposite = putProductsProductIdResponse200;
    
export type putProductsProductIdResponse = putProductsProductIdResponseComposite & {
  headers: Headers;
}

export const getPutProductsProductIdUrl = (productId: string,) => {


  

  return `/products/${productId}`
}

export const putProductsProductId = async (productId: string,
    productUpdateRequest: ProductUpdateRequest, options?: RequestInit): Promise<putProductsProductIdResponse> => {
  
  const res = await fetch(getPutProductsProductIdUrl(productId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      productUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putProductsProductIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putProductsProductIdResponse
}




export const getPutProductsProductIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putProductsProductId>>, TError,{productId: string;data: ProductUpdateRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putProductsProductId>>, TError,{productId: string;data: ProductUpdateRequest}, TContext> => {

const mutationKey = ['putProductsProductId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putProductsProductId>>, {productId: string;data: ProductUpdateRequest}> = (props) => {
          const {productId,data} = props ?? {};

          return  putProductsProductId(productId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutProductsProductIdMutationResult = NonNullable<Awaited<ReturnType<typeof putProductsProductId>>>
    export type PutProductsProductIdMutationBody = ProductUpdateRequest
    export type PutProductsProductIdMutationError = unknown

    /**
 * @summary ÂïÜÂìÅÊõ¥Êñ∞
 */
export const usePutProductsProductId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putProductsProductId>>, TError,{productId: string;data: ProductUpdateRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putProductsProductId>>,
        TError,
        {productId: string;data: ProductUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutProductsProductIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary ÂïÜÂìÅÂâäÈô§
 */
export type deleteProductsProductIdResponse204 = {
  data: null
  status: 204
}
    
export type deleteProductsProductIdResponseComposite = deleteProductsProductIdResponse204;
    
export type deleteProductsProductIdResponse = deleteProductsProductIdResponseComposite & {
  headers: Headers;
}

export const getDeleteProductsProductIdUrl = (productId: string,) => {


  

  return `/products/${productId}`
}

export const deleteProductsProductId = async (productId: string, options?: RequestInit): Promise<deleteProductsProductIdResponse> => {
  
  const res = await fetch(getDeleteProductsProductIdUrl(productId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteProductsProductIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteProductsProductIdResponse
}




export const getDeleteProductsProductIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductId>>, TError,{productId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductId>>, TError,{productId: string}, TContext> => {

const mutationKey = ['deleteProductsProductId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductsProductId>>, {productId: string}> = (props) => {
          const {productId} = props ?? {};

          return  deleteProductsProductId(productId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductsProductIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductsProductId>>>
    
    export type DeleteProductsProductIdMutationError = unknown

    /**
 * @summary ÂïÜÂìÅÂâäÈô§
 */
export const useDeleteProductsProductId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductId>>, TError,{productId: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteProductsProductId>>,
        TError,
        {productId: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductsProductIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    