/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * PIM (Product Information Management) API
 * ÂïÜÂìÅÊÉÖÂ†±ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆAPIÂÆöÁæ©
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  PostProductsProductIdImagesBody,
  ProductImage,
  ProductImageUpdateRequest
} from '../../model';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * @summary ÂïÜÂìÅÁîªÂÉè‰∏ÄË¶ßÂèñÂæó
 */
export type getProductsProductIdImagesResponse200 = {
  data: ProductImage[]
  status: 200
}
    
export type getProductsProductIdImagesResponseComposite = getProductsProductIdImagesResponse200;
    
export type getProductsProductIdImagesResponse = getProductsProductIdImagesResponseComposite & {
  headers: Headers;
}

export const getGetProductsProductIdImagesUrl = (productId: string,) => {


  

  return `/products/${productId}/images`
}

export const getProductsProductIdImages = async (productId: string, options?: RequestInit): Promise<getProductsProductIdImagesResponse> => {
  
  const res = await fetch(getGetProductsProductIdImagesUrl(productId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getProductsProductIdImagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getProductsProductIdImagesResponse
}



export const getGetProductsProductIdImagesQueryKey = (productId?: string,) => {
    return [`/products/${productId}/images`] as const;
    }

    
export const getGetProductsProductIdImagesQueryOptions = <TData = Awaited<ReturnType<typeof getProductsProductIdImages>>, TError = unknown>(productId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProductsProductIdImages>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductsProductIdImagesQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductsProductIdImages>>> = ({ signal }) => getProductsProductIdImages(productId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductsProductIdImages>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProductsProductIdImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getProductsProductIdImages>>>
export type GetProductsProductIdImagesQueryError = unknown


/**
 * @summary ÂïÜÂìÅÁîªÂÉè‰∏ÄË¶ßÂèñÂæó
 */

export function useGetProductsProductIdImages<TData = Awaited<ReturnType<typeof getProductsProductIdImages>>, TError = unknown>(
 productId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProductsProductIdImages>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetProductsProductIdImagesQueryOptions(productId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary ÂïÜÂìÅÁîªÂÉèËøΩÂä†
 */
export type postProductsProductIdImagesResponse201 = {
  data: ProductImage
  status: 201
}
    
export type postProductsProductIdImagesResponseComposite = postProductsProductIdImagesResponse201;
    
export type postProductsProductIdImagesResponse = postProductsProductIdImagesResponseComposite & {
  headers: Headers;
}

export const getPostProductsProductIdImagesUrl = (productId: string,) => {


  

  return `/products/${productId}/images`
}

export const postProductsProductIdImages = async (productId: string,
    postProductsProductIdImagesBody: PostProductsProductIdImagesBody, options?: RequestInit): Promise<postProductsProductIdImagesResponse> => {
    const formData = new FormData();
if(postProductsProductIdImagesBody.file !== undefined) {
 formData.append(`file`, postProductsProductIdImagesBody.file)
 }
if(postProductsProductIdImagesBody.image_type !== undefined) {
 formData.append(`image_type`, postProductsProductIdImagesBody.image_type)
 }
if(postProductsProductIdImagesBody.alt_text !== undefined) {
 formData.append(`alt_text`, postProductsProductIdImagesBody.alt_text)
 }
if(postProductsProductIdImagesBody.display_order !== undefined) {
 formData.append(`display_order`, postProductsProductIdImagesBody.display_order.toString())
 }

  const res = await fetch(getPostProductsProductIdImagesUrl(productId),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postProductsProductIdImagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postProductsProductIdImagesResponse
}




export const getPostProductsProductIdImagesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postProductsProductIdImages>>, TError,{productId: string;data: PostProductsProductIdImagesBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postProductsProductIdImages>>, TError,{productId: string;data: PostProductsProductIdImagesBody}, TContext> => {

const mutationKey = ['postProductsProductIdImages'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postProductsProductIdImages>>, {productId: string;data: PostProductsProductIdImagesBody}> = (props) => {
          const {productId,data} = props ?? {};

          return  postProductsProductIdImages(productId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostProductsProductIdImagesMutationResult = NonNullable<Awaited<ReturnType<typeof postProductsProductIdImages>>>
    export type PostProductsProductIdImagesMutationBody = PostProductsProductIdImagesBody
    export type PostProductsProductIdImagesMutationError = unknown

    /**
 * @summary ÂïÜÂìÅÁîªÂÉèËøΩÂä†
 */
export const usePostProductsProductIdImages = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postProductsProductIdImages>>, TError,{productId: string;data: PostProductsProductIdImagesBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postProductsProductIdImages>>,
        TError,
        {productId: string;data: PostProductsProductIdImagesBody},
        TContext
      > => {

      const mutationOptions = getPostProductsProductIdImagesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary ÂïÜÂìÅÁîªÂÉèÊõ¥Êñ∞
 */
export type putProductsProductIdImagesImageIdResponse200 = {
  data: ProductImage
  status: 200
}
    
export type putProductsProductIdImagesImageIdResponseComposite = putProductsProductIdImagesImageIdResponse200;
    
export type putProductsProductIdImagesImageIdResponse = putProductsProductIdImagesImageIdResponseComposite & {
  headers: Headers;
}

export const getPutProductsProductIdImagesImageIdUrl = (productId: string,
    imageId: string,) => {


  

  return `/products/${productId}/images/${imageId}`
}

export const putProductsProductIdImagesImageId = async (productId: string,
    imageId: string,
    productImageUpdateRequest: ProductImageUpdateRequest, options?: RequestInit): Promise<putProductsProductIdImagesImageIdResponse> => {
  
  const res = await fetch(getPutProductsProductIdImagesImageIdUrl(productId,imageId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      productImageUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putProductsProductIdImagesImageIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putProductsProductIdImagesImageIdResponse
}




export const getPutProductsProductIdImagesImageIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string;data: ProductImageUpdateRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string;data: ProductImageUpdateRequest}, TContext> => {

const mutationKey = ['putProductsProductIdImagesImageId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>, {productId: string;imageId: string;data: ProductImageUpdateRequest}> = (props) => {
          const {productId,imageId,data} = props ?? {};

          return  putProductsProductIdImagesImageId(productId,imageId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutProductsProductIdImagesImageIdMutationResult = NonNullable<Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>>
    export type PutProductsProductIdImagesImageIdMutationBody = ProductImageUpdateRequest
    export type PutProductsProductIdImagesImageIdMutationError = unknown

    /**
 * @summary ÂïÜÂìÅÁîªÂÉèÊõ¥Êñ∞
 */
export const usePutProductsProductIdImagesImageId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string;data: ProductImageUpdateRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putProductsProductIdImagesImageId>>,
        TError,
        {productId: string;imageId: string;data: ProductImageUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutProductsProductIdImagesImageIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary ÂïÜÂìÅÁîªÂÉèÂâäÈô§
 */
export type deleteProductsProductIdImagesImageIdResponse204 = {
  data: null
  status: 204
}
    
export type deleteProductsProductIdImagesImageIdResponseComposite = deleteProductsProductIdImagesImageIdResponse204;
    
export type deleteProductsProductIdImagesImageIdResponse = deleteProductsProductIdImagesImageIdResponseComposite & {
  headers: Headers;
}

export const getDeleteProductsProductIdImagesImageIdUrl = (productId: string,
    imageId: string,) => {


  

  return `/products/${productId}/images/${imageId}`
}

export const deleteProductsProductIdImagesImageId = async (productId: string,
    imageId: string, options?: RequestInit): Promise<deleteProductsProductIdImagesImageIdResponse> => {
  
  const res = await fetch(getDeleteProductsProductIdImagesImageIdUrl(productId,imageId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteProductsProductIdImagesImageIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteProductsProductIdImagesImageIdResponse
}




export const getDeleteProductsProductIdImagesImageIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string}, TContext> => {

const mutationKey = ['deleteProductsProductIdImagesImageId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>, {productId: string;imageId: string}> = (props) => {
          const {productId,imageId} = props ?? {};

          return  deleteProductsProductIdImagesImageId(productId,imageId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductsProductIdImagesImageIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>>
    
    export type DeleteProductsProductIdImagesImageIdMutationError = unknown

    /**
 * @summary ÂïÜÂìÅÁîªÂÉèÂâäÈô§
 */
export const useDeleteProductsProductIdImagesImageId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>, TError,{productId: string;imageId: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteProductsProductIdImagesImageId>>,
        TError,
        {productId: string;imageId: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductsProductIdImagesImageIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    