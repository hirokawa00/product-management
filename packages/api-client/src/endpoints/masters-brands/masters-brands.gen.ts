/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * PIM (Product Information Management) API
 * ÂïÜÂìÅÊÉÖÂ†±ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆAPIÂÆöÁæ©
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Brand,
  BrandCreateRequest,
  BrandUpdateRequest
} from '../../model';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * @summary „Éñ„É©„É≥„Éâ‰∏ÄË¶ßÂèñÂæó
 */
export type getMastersBrandsResponse200 = {
  data: Brand[]
  status: 200
}
    
export type getMastersBrandsResponseComposite = getMastersBrandsResponse200;
    
export type getMastersBrandsResponse = getMastersBrandsResponseComposite & {
  headers: Headers;
}

export const getGetMastersBrandsUrl = () => {


  

  return `/masters/brands`
}

export const getMastersBrands = async ( options?: RequestInit): Promise<getMastersBrandsResponse> => {
  
  const res = await fetch(getGetMastersBrandsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getMastersBrandsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getMastersBrandsResponse
}



export const getGetMastersBrandsQueryKey = () => {
    return [`/masters/brands`] as const;
    }

    
export const getGetMastersBrandsQueryOptions = <TData = Awaited<ReturnType<typeof getMastersBrands>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMastersBrands>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMastersBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMastersBrands>>> = ({ signal }) => getMastersBrands({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMastersBrands>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMastersBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof getMastersBrands>>>
export type GetMastersBrandsQueryError = unknown


/**
 * @summary „Éñ„É©„É≥„Éâ‰∏ÄË¶ßÂèñÂæó
 */

export function useGetMastersBrands<TData = Awaited<ReturnType<typeof getMastersBrands>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMastersBrands>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMastersBrandsQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary „Éñ„É©„É≥„Éâ‰ΩúÊàê
 */
export type postMastersBrandsResponse201 = {
  data: Brand
  status: 201
}
    
export type postMastersBrandsResponseComposite = postMastersBrandsResponse201;
    
export type postMastersBrandsResponse = postMastersBrandsResponseComposite & {
  headers: Headers;
}

export const getPostMastersBrandsUrl = () => {


  

  return `/masters/brands`
}

export const postMastersBrands = async (brandCreateRequest: BrandCreateRequest, options?: RequestInit): Promise<postMastersBrandsResponse> => {
  
  const res = await fetch(getPostMastersBrandsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      brandCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postMastersBrandsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postMastersBrandsResponse
}




export const getPostMastersBrandsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMastersBrands>>, TError,{data: BrandCreateRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postMastersBrands>>, TError,{data: BrandCreateRequest}, TContext> => {

const mutationKey = ['postMastersBrands'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMastersBrands>>, {data: BrandCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postMastersBrands(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMastersBrandsMutationResult = NonNullable<Awaited<ReturnType<typeof postMastersBrands>>>
    export type PostMastersBrandsMutationBody = BrandCreateRequest
    export type PostMastersBrandsMutationError = unknown

    /**
 * @summary „Éñ„É©„É≥„Éâ‰ΩúÊàê
 */
export const usePostMastersBrands = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMastersBrands>>, TError,{data: BrandCreateRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postMastersBrands>>,
        TError,
        {data: BrandCreateRequest},
        TContext
      > => {

      const mutationOptions = getPostMastersBrandsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary „Éñ„É©„É≥„ÉâË©≥Á¥∞ÂèñÂæó
 */
export type getMastersBrandsBrandIdResponse200 = {
  data: Brand
  status: 200
}
    
export type getMastersBrandsBrandIdResponseComposite = getMastersBrandsBrandIdResponse200;
    
export type getMastersBrandsBrandIdResponse = getMastersBrandsBrandIdResponseComposite & {
  headers: Headers;
}

export const getGetMastersBrandsBrandIdUrl = (brandId: string,) => {


  

  return `/masters/brands/${brandId}`
}

export const getMastersBrandsBrandId = async (brandId: string, options?: RequestInit): Promise<getMastersBrandsBrandIdResponse> => {
  
  const res = await fetch(getGetMastersBrandsBrandIdUrl(brandId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getMastersBrandsBrandIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getMastersBrandsBrandIdResponse
}



export const getGetMastersBrandsBrandIdQueryKey = (brandId?: string,) => {
    return [`/masters/brands/${brandId}`] as const;
    }

    
export const getGetMastersBrandsBrandIdQueryOptions = <TData = Awaited<ReturnType<typeof getMastersBrandsBrandId>>, TError = unknown>(brandId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMastersBrandsBrandId>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMastersBrandsBrandIdQueryKey(brandId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMastersBrandsBrandId>>> = ({ signal }) => getMastersBrandsBrandId(brandId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(brandId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMastersBrandsBrandId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMastersBrandsBrandIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMastersBrandsBrandId>>>
export type GetMastersBrandsBrandIdQueryError = unknown


/**
 * @summary „Éñ„É©„É≥„ÉâË©≥Á¥∞ÂèñÂæó
 */

export function useGetMastersBrandsBrandId<TData = Awaited<ReturnType<typeof getMastersBrandsBrandId>>, TError = unknown>(
 brandId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMastersBrandsBrandId>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMastersBrandsBrandIdQueryOptions(brandId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary „Éñ„É©„É≥„ÉâÊõ¥Êñ∞
 */
export type putMastersBrandsBrandIdResponse200 = {
  data: Brand
  status: 200
}
    
export type putMastersBrandsBrandIdResponseComposite = putMastersBrandsBrandIdResponse200;
    
export type putMastersBrandsBrandIdResponse = putMastersBrandsBrandIdResponseComposite & {
  headers: Headers;
}

export const getPutMastersBrandsBrandIdUrl = (brandId: string,) => {


  

  return `/masters/brands/${brandId}`
}

export const putMastersBrandsBrandId = async (brandId: string,
    brandUpdateRequest: BrandUpdateRequest, options?: RequestInit): Promise<putMastersBrandsBrandIdResponse> => {
  
  const res = await fetch(getPutMastersBrandsBrandIdUrl(brandId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      brandUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putMastersBrandsBrandIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putMastersBrandsBrandIdResponse
}




export const getPutMastersBrandsBrandIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMastersBrandsBrandId>>, TError,{brandId: string;data: BrandUpdateRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putMastersBrandsBrandId>>, TError,{brandId: string;data: BrandUpdateRequest}, TContext> => {

const mutationKey = ['putMastersBrandsBrandId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putMastersBrandsBrandId>>, {brandId: string;data: BrandUpdateRequest}> = (props) => {
          const {brandId,data} = props ?? {};

          return  putMastersBrandsBrandId(brandId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutMastersBrandsBrandIdMutationResult = NonNullable<Awaited<ReturnType<typeof putMastersBrandsBrandId>>>
    export type PutMastersBrandsBrandIdMutationBody = BrandUpdateRequest
    export type PutMastersBrandsBrandIdMutationError = unknown

    /**
 * @summary „Éñ„É©„É≥„ÉâÊõ¥Êñ∞
 */
export const usePutMastersBrandsBrandId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMastersBrandsBrandId>>, TError,{brandId: string;data: BrandUpdateRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putMastersBrandsBrandId>>,
        TError,
        {brandId: string;data: BrandUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutMastersBrandsBrandIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary „Éñ„É©„É≥„ÉâÂâäÈô§
 */
export type deleteMastersBrandsBrandIdResponse204 = {
  data: null
  status: 204
}
    
export type deleteMastersBrandsBrandIdResponseComposite = deleteMastersBrandsBrandIdResponse204;
    
export type deleteMastersBrandsBrandIdResponse = deleteMastersBrandsBrandIdResponseComposite & {
  headers: Headers;
}

export const getDeleteMastersBrandsBrandIdUrl = (brandId: string,) => {


  

  return `/masters/brands/${brandId}`
}

export const deleteMastersBrandsBrandId = async (brandId: string, options?: RequestInit): Promise<deleteMastersBrandsBrandIdResponse> => {
  
  const res = await fetch(getDeleteMastersBrandsBrandIdUrl(brandId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteMastersBrandsBrandIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteMastersBrandsBrandIdResponse
}




export const getDeleteMastersBrandsBrandIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>, TError,{brandId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>, TError,{brandId: string}, TContext> => {

const mutationKey = ['deleteMastersBrandsBrandId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>, {brandId: string}> = (props) => {
          const {brandId} = props ?? {};

          return  deleteMastersBrandsBrandId(brandId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMastersBrandsBrandIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>>
    
    export type DeleteMastersBrandsBrandIdMutationError = unknown

    /**
 * @summary „Éñ„É©„É≥„ÉâÂâäÈô§
 */
export const useDeleteMastersBrandsBrandId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>, TError,{brandId: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteMastersBrandsBrandId>>,
        TError,
        {brandId: string},
        TContext
      > => {

      const mutationOptions = getDeleteMastersBrandsBrandIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    